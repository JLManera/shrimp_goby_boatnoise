---
title: "shrimp_goby_boatnoise"
author: "Jack L Manera & Jake M Martin"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_download: true
    code_folding: hide
    depth: 4
    number_sections: yes
    theme:  cosmo
    toc: yes
    toc_float: yes
    toc_depth: 4
  pdf_document:
    toc: yes
knit: |
  (function(input, ...) {
    rmarkdown::render(
      input,
      output_file = paste0(
       'index.html'
      ),
      envir = globalenv()
    )
  })
---

<!------------------------------->
# 📕 READ ME   
<!------------------------------->

     
**🚧 UNPUBLISHED AND ONGOING 🚧 **   
The data in this script is currently **unpublished**. There may be part of this script that are currently incomplete. This script has been made publicly available for easy of sharing with collaborators and colleagues who are interested in the progression of the project and for complete transparency.   

-------

**SUMMARY**  
Human activities are reshaping marine soundscapes globally, with persistent low-frequency noise from boat traffic recognised as a primary driver of marine noise pollution. Despite growing concern, empirical data for most marine life, in natural settings, remains sparse, particularly for fish and crustaceans whose auditory ranges overlap with the frequencies of boat noise. Accordingly, we conducted a field experiment to evaluate how boat noise from different engine types (2-stroke and 4-stroke) affects the mutualistic partnership between Steinitz’s goby (Amblyeleotris steinitzi) and snapping shrimp (Alpheus spp.). Across 123 mutualistic partnerships, we recorded behavioural responses before, during, and after noise exposure. Both species increased burrow use during noise exposure, indicating heightened risk perception, yet their tactile communication—critical for the functioning of the mutualism—remained unaltered. Notably, gobies responded more strongly to 4-stroke boat noise, reducing time outside their burrows by 22%, while shrimp were more sensitive to 2-stroke noise, reducing burrow use by 34%, reflecting species-specific sensitivities to different noise spectra. Behavioural changes were transient, rapidly reverting to baseline levels after the noise exposure stopped. These findings highlight divergent vulnerabilities tied to different engine acoustics and emphasise the need for targeted research to inform strategies for mitigating marine noise pollution.

-------

**AIM**  
This study employs a field-based experimental approach to investigate the impacts of boat noise on an iconic behavioural mutualism between gobies (Amblyeleotris steinitzi) and shrimp (Alpheus spp). We test the hypothesis that boat noise exposure (2-stroke and 4-stroke engines) would alter the mutualism of these two species by independently altering perceived risk, leading to shifts in behaviour, and potentially disrupting their communication.

-------

**AUTHORS**  
Jack L. Manera^1†^   
Jake M. Martin^1,2,3†^    
Maria M. Palacios^4^ 
Rachel T Mason^3^    
Mark I. McCormick^5^    
Bob BM. Wong^1^    

-------

**AFFILIATIONS**    
^1^School of Biological Sciences, Monash University, Clayton, Victoria 3800, Australia   
^2^School of Life and Environmental Sciences, Deakin University, Waurn Ponds, Victoria 3216, Australia   
^3^Department of Wildlife, Fish, and Environmental Studies, Swedish University of Agricultural Sciences, Umeå, Sweden   
^4^Centre for Nature Positive Solutions, School of Science, RMIT University, Melbourne, Victoria 3100, Australia   
^5^Coastal Marine Field Station, School of Science, University of Waikato, Tauranga, New Zealand   
^†^These authors contributed equally as lead investigators 

-------

**CONTRIBUTOR ROLES**  
*🚧 to be added 🚧*

<!------------------------------->
# 📑 Sharing/accessing and citing
<!------------------------------->

**Licenses/restrictions placed on the data:** CC-BY 4.0  

**Link to the associated publication:**     
🚧 *To be added* 🚧     

**Recommended citation for this data:**      
🚧 *To be added based on OSF DOI* 🚧     


<!------------------------------->
# 📧 Contact
<!------------------------------->

**Jack L. Manera**    

📧 **Email:** [jack.manera@monash.edu](mailto:jack.manera@monash.edu)  
  
🌐 **Web:** *🚧 to be added 🚧*  
  
🐙 **GitHub**: [JLManera](https://github.com/JLManera)    

     
-------

**Jake M. Martin**
  
📧 **Email:** [jake.martin@deakin.edu.au](mailto:jake.martin@deakin.edu.au)  
  
📧 **Alt Email:** [jake.martin.research@gmail.com](mailto:jake.martin.research@gmail.com) 
  
🌐 **Web:** [jakemartin.org](https://jakemartin.org/)  
  
🐙 **GitHub**: [JakeMartinResearch](https://github.com/JakeMartinResearch)   

<!------------------------------->
# ⚙️ Knit settings 
<!------------------------------->

Here we define our Knit settings, to make the output more user friendly, and to cache output for faster knitting.  

```{r setup}
#kniter seetting
knitr::opts_chunk$set(
message = FALSE,
warning = FALSE, # no warnings
cache = TRUE,# Cacheing to save time when kniting
tidy = TRUE
)
```


<!------------------------------->
# 📦 Required packages
<!------------------------------->

These are the R packages required for this script. You will need to install a package called pacman to run the p_load function and cmdstanr as a lightwight backend for running the brms models.    

```{r, message=FALSE, results='hide'}
#install.packages("pacman")
#install.packages("cmdstanr", repos = c('https://stan-dev.r-universe.dev', getOption("repos")))

pacman::p_load(tidyverse, ggplot2, brms, cmdstanr, broom, broom.mixed, tidybayes, ggthemes, emmeans, ggdist, gridExtra, bayesplot, see, patchwork, ggtext, extraDistr, gghalves, ggpp, rstan, gt) 
```

<!------------------------------->
# 🤠 Data wrangling
<!------------------------------->

Setting colour palette for visualisations   

```{r}
# Setting colours for visualisations
colour1 <- "#97A275"
colour2 <- "#F2B23A"
colour3 <- "#F2711B"
colour4 <- "#8CBEB2"
colour5 <- "#E7C27D"
colour6 <- "#F2A775"
colour11 <- "#666E4F"
colour12 <- "#A38346"
colour13 <- "#9C4811"
```

## Directories

Assigning the directory so that the code can be universally read on any computer as long as the entire project file is shared. This is a relative path.  

```{r}
directory <- './1-data/'
```

## Data

Here we load in the three date files 

- **💿 BORIS_output.csv**: This is the summary output from the BORIS, the key logging software used for behavioural observations. This includes the occurrence count and total duration of each of the measured behaviour endpoints, for each shrimp and each goby across all trials. They are identified with the code column.     

```{r}
BORIS_output <- read.csv("./1-data/BORIS_output.csv")
```

- **💿 Video_codes.csv**: This has meta data for each video, include treatment information and associated codes.

```{r}
Video_codes <- read.csv("./1-data/Video_codes.csv")
```

- **💿 species.csv**: This is the species name for the shrimp in each of the videos

```{r}
shrimp_species <- read.csv("./1-data/species.csv")
```

## Unblinding data

Now we unbind the treatment code form behavioural observations (all behaviours were scored blind to treatment). This is done using video code column. 

```{r}
#binding the decoder to the BORIS output and revealing the treatment and stage
BORIS_output$code <- str_sub(BORIS_output$video_id, 2,)
BORIS_output$code <- as.factor(BORIS_output$code)
shrimp_species$code <- as.factor(shrimp_species$code)
Video_codes$code <- as.factor(Video_codes$code)
decoded_dataframe <- inner_join(inner_join(BORIS_output, Video_codes, by = c("code")), shrimp_species, by = c("code"))
```

## Cross-checking the imported datasets

There were instances where burrows were recorded and assigned video codes but showed no activity from gobies or shrimp during these recordings. These instances led to the assumption that such burrows were inactive, resulting in their exclusion from the further analysis of the study.  

```{r}
# Find common codes across all data sets
common_codes <- Reduce(intersect, list(BORIS_output$code, shrimp_species$code, Video_codes$code))

# Combine all codes from the three data sets
all_codes <- unique(c(BORIS_output$code, shrimp_species$code, Video_codes$code))

# Find codes not common across all data sets
codes_not_common <- setdiff(all_codes, common_codes)

# Define a function to check which data sets contain each code
check_code_origin <- function(code) {
  origins <- c()

  if(code %in% BORIS_output$code) {
    origins <- c(origins, "BORIS_output")
  }
  if(code %in% shrimp_species$code) {
    origins <- c(origins, "shrimp_species")
  }
  if(code %in% Video_codes$code) {
    origins <- c(origins, "Video_codes")
  }

  return(paste(origins, collapse=", "))
}

# Create a dataframe to store the results
results <- data.frame(code = character(0), origin = character(0), stringsAsFactors = FALSE)

# Loop through each code not common across all data sets
for(code in codes_not_common) {
  origin <- check_code_origin(code)
  results <- rbind(results, data.frame(code = as.character(code), origin = origin, stringsAsFactors = FALSE))
}

# Print the results
print(results)
```

##  Cleaning the dataframe

### Column renaming

Renaming some of the variables and extracting individual variables from columns that have multiple variables contained in one string   

```{r}
decoded_dataframe <- decoded_dataframe |> 
  rename(shrimp_species = species)

decoded_dataframe <- decoded_dataframe |> 
  dplyr::rename(stage = video_section,
                duration = total_duration_s,
                behaviour = behavior) |>
  dplyr::mutate(date = str_sub(date_file, , 6),
                species = str_sub(subject, 5,),
                duration = as.numeric(duration),
                boat_id = str_sub(date_file, -1, -1),
                video_num = as.numeric(str_sub(video_id, 2)),
                burrow = ceiling(video_num/3),
                individual = str_sub(subject, 1, 1),
                stroke = factor(stroke),
                boat_name = factor(boat_name)
                )
```

Creating some unique identifiers to make grouping easier later on for reorganising of the data frame.   

```{r}
decoded_dataframe <- decoded_dataframe |> 
  unite("unique_id", 'burrow','individual', 'species', 'stage', remove = FALSE) |> 
  unite("burrow_species_stage", 'burrow', 'species', 'stage', remove = FALSE) |> 
  unite("burrow_species", 'burrow', 'species', remove = FALSE)
```

### Removing redundant BORIS entries

Here we clean the BROIS output data, where there was redundant empty sections due to both species being independently scored in the software. So here we are filtering out the species specific data from the correlating BORIS species observation and then rebinding the data to remove all of the empty artifact entries. 

```{r}
#extracting just the goby data so that a species variable can be made
goby_dataframe <- decoded_dataframe |> 
  dplyr::filter(species == "Goby") |> 
  dplyr::filter(str_detect(video_id, 'g'))

#extracting just the shrimp data so that a species variable can be made
shrimp_dataframe <- decoded_dataframe |> 
  dplyr::filter(species == "Shrimp")  |>  
  dplyr::filter(str_detect(video_id, 'j'))

#binding the two species specific data frames back together so that there is now no empty 
workingdf1 <- bind_rows(goby_dataframe, shrimp_dataframe) 

#filtering for the behviours of interest to this experiment
workingdf2 <- workingdf1 |> 
  group_by(unique_id) |> 
  dplyr::filter(behaviour == 'INSIDE' | behaviour == 'EDGE' | behaviour == 'NEAR' | behaviour == 'AWAY' |behaviour == 'CONTACT' |behaviour == 'APART' ) |>
  mutate(averageduration = sum(duration))

#becuase of the way BORIS outputs data there are redundant individuals in the data, e.g., even if there are only two shrimp in a burrow then BORIS will still output observations for a third shrimp and all value will be 0's. this is what this section of code is removing
workingdf3 <- workingdf2 |> 
  group_by(burrow, species, individual) |> 
  dplyr::filter(sum(averageduration) != 0)
```

### Assigning Values to Zero Entries

During some trial phases, only one individual of a species was observed at a time. However, we know from observations in other phases of the same trial that multiple individuals were actually present. For example, in burrow X, only a single shrimp may have been seen during the noise exposure phase, but two shrimp were observed at the same time in the pre-noise exposure phase.

This issue leads to incomplete behavioral data because the second individual is assigned zeros across all behavioral states. However, since the individual does exist, it must be in one of the four behavioral states: INSIDE, EDGE, NEAR, or AWAY. This suggests that the individual either:
(1) Remained out of frame ("AWAY") for the entire phase.
(2) Stayed inside the burrow ("INSIDE") for the entire phase.
(3) Alternated visibility with the first individual, meaning only one individual of that species was observed at any given time.

To correct for this, we apply the following biologically informed assumptions:
- If **a goby is observed in other videos but missing from a given phase**, it is **"away"** (out of frame for the entire phase).
- If **a shrimp is missing**, it is **"inside"** the burrow for the entire phase.

These assumptions are based on our team's direct observations and previously documented biological tendencies of each species. While they are well-supported for cases (1) and (2), case (3) presents a challenge, as individual identity could not be maintained. Since behaviors could not be reliably assigned to a specific individual, we instead compute species-level averages for each burrow in the following code. This approach ensures that even if individuals were alternating in visibility, assigning one individual as "away" or "inside" for an entire trial does not compromise the overall behavioral representation. By averaging at the species level, we capture the broader behavioral patterns of the group.

```{r}
fixeddf1 <- workingdf3 |> 
  dplyr::filter(averageduration == 0) |> 
  mutate(duration = ifelse(species == "Goby" & behaviour == "AWAY", 300, duration),
         duration = ifelse(species == "Shrimp" & behaviour == "INSIDE", 300, duration)
         )

fixeddf2 <- workingdf3 |> 
  dplyr::filter(averageduration != 0)

workingdf4 <- rbind(fixeddf2, fixeddf1) |> 
  group_by(burrow_species) |> 
  dplyr::mutate(number_conspecifics = max(as.integer(individual))) |> 
  ungroup()

#now using the number of conspecifics to calculate a duration value that represents the mean time spent doing that activity for that species (i.e. goby or shrimp) in that burrow as we are un able to preserve identity and thus instead must look at species averages for each behaviour. 
workingdf5 <- workingdf4 |> 
  group_by(burrow_species, behaviour, stage) |> 
  dplyr::mutate(mean_duration = mean(duration)) |> 
  ungroup() |> 
  dplyr::filter(individual == 1) 
```

###Converting durations to proportions

Here we converte absolute duration of each behaviour to proportional time budgets (0-1 scale).

```{r}
#transforming the data frame into wide format and turning time spent in each zone into a proportion of the total time (i.e. a value between 0 and 1)
wide_data <- workingdf5 |>
  pivot_wider(
    id_cols = c(burrow_species, burrow_species_stage, burrow, stage, species, boat_id, stroke, site, number_conspecifics, shrimp_species),
    names_from = behaviour,
    values_from = mean_duration
  )

wide_data <- wide_data |> 
  mutate(INSIDE = as.numeric(INSIDE),
         EDGE = as.numeric(EDGE),
         NEAR = as.numeric(NEAR),
         AWAY = as.numeric(AWAY),
         CONTACT = as.numeric(CONTACT),
         APART = as.numeric(APART)) |> 
  mutate(total = INSIDE+NEAR+EDGE+AWAY,
         inside = (INSIDE + EDGE)/(INSIDE+EDGE+NEAR+AWAY), 
         away = (NEAR + AWAY)/(INSIDE+EDGE+NEAR+AWAY),
         number_conspecifics = as.factor(number_conspecifics),
         shrimp_contact = CONTACT/(CONTACT+APART)
         ) |> 
  dplyr::select(-INSIDE, -EDGE, -NEAR, -AWAY, -CONTACT, -APART)
```

###Validating complete burrow records

We identified and removed burrows that lacked records for both species. Without evidence of both species, we could not confidently confirm their coexistence in the burrow. Therefore, to ensure a focus on mutualistic pairs, we excluded partial records where only one species was observed.

```{r}
#checking if every burrow contains observations for both 'Shrimp' and 'Goby'
burrow_values <- unique(wide_data$burrow) 
has_shrimp <- burrow_values %in% wide_data$burrow[wide_data$species == 'Shrimp'] 
has_goby <- burrow_values %in% wide_data$burrow[wide_data$species == 'Goby'] 
burrows_without_both_species <- burrow_values[!(has_shrimp & has_goby)]
cat("burrows without both 'Shrimp' and 'Goby' species:", paste(burrows_without_both_species, collapse = ', '))

#removing the rows with burrows without both 'Shrimp' and 'Goby' species from the dataframe
wide_data <- wide_data[!wide_data$burrow %in% burrows_without_both_species, ]

wide_data <- wide_data |> 
  mutate(burrow = as.factor(burrow))

#Checking to see the count of observations per burrow
burrow_counts <- table(wide_data$burrow)
print(burrow_counts)
```

### Assigning values to missing entries

In some cases, a species was not observed during an entire video, although other videos confirmed its presence in the same burrow. These instances were not captured by the earlier code designed for "Assigning Values to Zero Entries." As a result, we need to assign values to these missing entries using the same approach and assumptions. Specifically, all gobies are considered AWAY for the entire trial segment, while all shrimp are considered inside the burrow for the entire segment.

```{r}
#a function to fill the missing stages for each species within each burrow
fill_missing_stages <- function(df) {
  all_stages <- c('Pre', 'During', 'Post')
  
  missing_stages <- setdiff(all_stages, unique(df$stage))
  
  if(length(missing_stages) == 0) return(data.frame())
  
  common_values <- df[1, ]
  
  new_rows <- data.frame()
  
  for(stage in missing_stages) {
    new_row <- common_values
    new_row$stage <- stage
    
    # Set column values based on species
    if(new_row$species == "Goby") {
      new_row$away <- 1
      new_row$inside <- 0
      new_row$total <- 300
      new_row$shrimp_contact <- 0
    } else if(new_row$species == "Shrimp") {
      new_row$away <- 0
      new_row$inside <- 1
      new_row$total <- 300
      new_row$shrimp_contact <- NA
    }
    
    new_rows <- rbind(new_rows, new_row)
  }
  
  return(new_rows)
}

#applying the function
fixeddf3 <- wide_data |>
  group_by(burrow_species) |>
  do(fill_missing_stages(.)) |>
  ungroup()

wide_data_filled <- rbind(wide_data, fixeddf3)
  
#Checking to see the count of observations per burrow to ensure the code has worked
filled_burrow_counts <- table(wide_data_filled$burrow)
print(filled_burrow_counts)
```

### Changing dataframe format 

Restructure the data frame for easier analysis. We also write this file as **💿 final_df.csv** in the the 📁 `./1-data` folder. This is what we will use for analysis.  

```{r}
workingdf7 <- wide_data_filled |> 
  mutate(burrow_stage = paste(burrow, stage))

goby_df <- workingdf7 |> 
  dplyr::filter(species == "Goby") |> 
  rename(goby_out = away, goby_total = total, goby_number = number_conspecifics) |> 
  select(-c("inside", "species", "burrow_species", "burrow_species_stage", "shrimp_contact"))

shrimp_df <- workingdf7 |> 
  dplyr::filter(species == "Shrimp") |> 
  rename(shrimp_out = away, shrimp_total = total, shrimp_number = number_conspecifics) |> 
  select(c("shrimp_out", "shrimp_total", "shrimp_number", "burrow_stage", "shrimp_contact"))

final_df <- inner_join(goby_df, shrimp_df, by = "burrow_stage") |> 
  mutate(shrimp_contact = ifelse(is.na(shrimp_contact), ifelse(goby_out == 1, 0, 1 - goby_out), shrimp_contact)) |> 
  filter(site != "SITE O")

write_csv(final_df, "./1-data/final_df.csv")
```

<!------------------------------->
# 🧮 Analysis 
<!------------------------------->

## 🐟 Gobies time outside of burrow

### Model struture

First we will build a global model for the proportion of time gobies spent out of the burrow

```{r}
zoib_formula <- bf(
  # mu (mean) part
  goby_out ~ stroke * stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # phi (precision) part
  phi ~ stroke * stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # alpha (zero-one-inflation) part
  zoi ~ stroke * stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # The one-inflated part, conditional on the 0s
  coi ~ stroke * stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  
  family = zero_one_inflated_beta()
)
```

### Specifying priors

#### Checking default priors

First we check default priors    

All the beta coefficients are being given a flat prior which means it can take on a value from - infinity to + infinity. All the beta coefficients are on the logit scale so lets plot how changing the value of beta relates to different proportions    

```{r}
get_prior(
  zoib_formula,
  data = final_df
) %>% 
  gt()
```

#### Graphing logit~proportion

After -5 or +5 the probability doesn't change much, instead of leaving our priors at the default of + and - infinity, we should say that they are most likely to occur between -5 and +5.    

```{r}
tibble(x = seq(-8, 8, by = 0.1)) |> 
  mutate(y = plogis(x)) |> 
  ggplot(aes(x = x, y = y)) +
  geom_line(size = 1) +
  labs(x = "Logit scale", y = "Probability scale") +
  theme_minimal()
```

#### Ploting priors

This visualises our priors, to aid in specification.      

```{r}
# Generate data points
x <- seq(-20, 20, length.out = 1000)  # Adjusted range for better visualization

# Define parameters for the distributions
loc_logistic <- 0
scale_logistic <- 3

df_student_t <- 3
loc_student_t <- 0
scale_student_t <- 2.5

loc_normal <- 0
scale_normal <- 3

# Calculate PDFs
pdf_logistic <- dlogis(x, location = loc_logistic, scale = scale_logistic)
pdf_student_t <- dt(x, df = df_student_t)
pdf_normal <- dnorm(x, mean = loc_normal, sd = scale_normal)

# Plot the PDFs
df <- data.frame(x = x, Logistic = pdf_logistic, Student_t = pdf_student_t, Normal = pdf_normal)
ggplot(df, aes(x)) +
  geom_line(aes(y = Logistic, color = "Logistic(0, 3)")) + # Default priors of Logistic(0,1) have been broadened as these priors seemed too restrictive
  geom_line(aes(y = Student_t, color = "Student_t(3, 0, 2.5)")) +
  geom_line(aes(y = Normal, color = "Normal(0, 3)")) + #For the beta coefficient prior, we will set it to be normally distributed around 0 with an sd of 5, here is the plotted prior distribution 
  labs(title = "Probability Density Functions",
       x = "x",
       y = "Probability Density") +
  scale_color_manual(name = "Distribution", values = c("Logistic(0, 3)" = "blue", "Student_t(3, 0, 2.5)" = "green", "Normal(0, 3)" = "red")) +
  theme_minimal()
```

#### Setting priors 

These are our specified priors, for the intercept have been left as the default and the coefficient priors defined above.   

```{r}
priors <- c(set_prior("student_t(3, 0, 2.5)", class = "Intercept"),
            set_prior("logistic(0, 3)", class = "Intercept", dpar = "coi"),
            set_prior("logistic(0, 3)", class = "Intercept", dpar = "zoi"),
            set_prior("student_t(3, 0, 2.5)", class = "Intercept", dpar = "phi", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", dpar = "phi", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", dpar = "zoi", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", dpar = "coi", lb = 0),
            set_prior("normal(0, 3)", class = "b"),
            set_prior("normal(0, 3)", class = "b", dpar = "phi"),
            set_prior("normal(0, 3)", class = "b", dpar = "zoi"),
            set_prior("normal(0, 3)", class = "b", dpar = "coi"))
```

#### Prior predictive check 

Here we will build a prior only model, to check the specification was reasonable

```{r}
prior_formula <- bf(
  # mu (mean) part
  goby_out ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # phi (precision) part
  phi ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # alpha (zero-one-inflation) part
  zoi ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # The one-inflated part, conditional on the 0s
  coi ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  
  family = zero_one_inflated_beta()
)

#Now we run and save the model. **unhash** the code below if you haven't downloaded the saved model 'goby_out_model.rds' in the "3-models" folder. 

# prior_model <- brm(
#   prior_formula,
#   data = final_df,
#   family = zero_one_inflated_beta(),
#   prior = priors,
#   control = list(adapt_delta = 0.99,
#                  max_treedepth = 12),
#   chains = 4, iter = 1000, warmup = 100,
#   cores = 4, threads = threading(2),
#   backend = "cmdstanr",
#   seed = 1,
#   sample_prior = "only",
#   file = "./3-models/prior_check"
# )

prior_model <-  readRDS(file = "./3-models/goby_out_model.rds")

color_scheme_set("red")
pp_check(prior_model, ndraws=20)
pp_check(prior_model, ndraws=100, type = 'stat', stat = 'mean')
```

### Final model structure

This is the structure of the final model

```{r}
goby_out_formula_1 <- bf(
  # mu (mean) part
  goby_out ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # phi (precision) part
  phi ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # alpha (zero-one-inflation) part
  zoi ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # The one-inflated part, conditional on the 0s
  coi ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  
  family = zero_one_inflated_beta()
)
```

### Running model

Now we run and save the model.

⏭️ **Skip this step** if you have downloaded the saved model 'goby_out_model.rds'. You will load the model in the next step.

```{r}
# goby_out_model <- brm(
#   goby_out_formula_1,
#   data = final_df,
#   family = zero_one_inflated_beta(),
#   prior = priors,
#   control = list(adapt_delta = 0.99,
#                  max_treedepth = 12),
#   chains = 4, iter = 4000, warmup = 1000,
#   cores = 4, threads = threading(2),
#   backend = "cmdstanr",
#   seed = 1,
#   file = "./3-models/goby_out_model"
# )
```

Here we reload the saved model.   

```{r}
goby_out_model <-  readRDS(file = "./3-models/goby_out_model.rds")
```

Looking at the basic model summary

```{r}
summary(goby_out_model)
```

### Model fit and diagnostics

#### Model convergence

Here we check the model convergence using R-hat   

```{r}
#convergence diagnostics (R-hat)
extract_rhats <- function(model) {
  model_summary <- summary(model)
  #extract R-hat values for fixed effects
  fixed_rhats <- model_summary$fixed[, "Rhat", drop = FALSE]
  #check for random effects and extract R-hat values if present
  if (!is.null(model_summary$random)) {
    random_rhats <- do.call(rbind, lapply(model_summary$random, function(x) x[, "Rhat", drop = FALSE]))
    #combine fixed and random effects R-hat values
    rhats <- rbind(fixed_rhats, random_rhats)
  } else {
    rhats <- fixed_rhats
  }
  
  return(rhats)
}

extract_rhats(goby_out_model) 
```

#### Model fit

Now we will asses model fit.   

```{r}
pp_check(goby_out_model, ndraws = 50)

pp_check(goby_out_model, type='stat', stat='mean')
```

Creating a summary of the observed data   

```{r}
summary(fitted(goby_out_model))
```

To compare with a summary of the predicted data, they seem to align very nicely.    

```{r}
summary(predict(goby_out_model))
```

### Posterior marginal effects

#### Pairwise contrasts of stroke and stage

```{r}
goby_out_contrast_effect <- goby_out_model |>
  emmeans(~ stroke*stage, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") 

# Extract the relevant contrast information
goby_out_results.table <- as.data.frame(goby_out_contrast_effect) |> 
  dplyr::filter(contrast %in% c("control Pre - 2 Pre", "control Pre - 4 Pre","4 Pre - 2 Pre", "control Pre - control During", "control Pre - control Post", "4 Pre - 4 During", "4 Pre - 4 Post", "2 Pre - 2 During", "2 Pre - 2 Post"))

goby_out_results.table %>% 
  gt()
```

Pull predicted contrast for a plot

```{r}
goby_out_contrast_draws <- goby_out_model |>
  emmeans(~ stroke*stage, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") |> 
  gather_emmeans_draws()

goby_out_temporal_contrasts <- goby_out_contrast_draws |> 
  dplyr::filter(contrast %in% c("control Pre - control During", "control Pre - control Post", "4 Pre - 4 During", "4 Pre - 4 Post", "2 Pre - 2 During", "2 Pre - 2 Post")) |> 
  mutate(stroke = ifelse(contrast %in% c("control Pre - control During", "control Pre - control Post"), "Control", ifelse(contrast %in% c("4 Pre - 4 During", "4 Pre - 4 Post"), "4", "2")))

goby_out_temporal_contrasts$stroke <- factor(goby_out_temporal_contrasts$stroke, levels = c("Control", "4", "2"))
```

Making a figure

```{r}
fig.goby_out_temporal_contrasts <- ggplot(goby_out_temporal_contrasts, aes(x = .value, y = factor(contrast, levels = c("control Pre - control During", "control Pre - control Post", "4 Pre - 4 During", "4 Pre - 4 Post", "2 Pre - 2 During", "2 Pre - 2 Post")), color = stroke, fill = stroke)) +
   geom_vline(xintercept = 0, color = "black", size = 0.5) +
  stat_halfeye(.width = c(0.89, 0.95))+
  scale_color_manual(values = c(colour11, colour12, colour13)) +
  scale_fill_manual(values = alpha(c(colour1, colour2, colour3), 0.8)) +
  labs(y = "Contrasts of the time periods relative to noise exposure",
       fill = "Noise treatment", color = "Noise treatment",
       fill_ramp = "Credible interval") +
  xlab(NULL) +
  coord_flip() +
  theme(legend.position = "right", 
        axis.text.x = element_text(angle = 50, hjust =1)) +
  scale_y_discrete(labels = c("Pre - During", "Pre - Post", "Pre - During", "Pre - Post", "Pre - During", "Pre - Post")) +
  scale_x_continuous(breaks = seq(-0.4, 0.5, 0.1), labels = c("-0.4","-0.3", "-0.2","-0.1" , "0", "0.1", "0.2", "0.3", "0.4", "0.5"), limits = c(-0.4, 0.4))

fig.goby_out_temporal_contrasts
```
### Extracting and plotting model estimates

#### Extracting estimates
```{r}
goby_out_model_estimates <- goby_out_model |> 
  emmeans(~ stroke*stage,
          epred = TRUE,
          rg.limit = 14000,
          re_formula = NA)

goby_out_model_estimates <- as.data.frame(goby_out_model_estimates)

#Storing the model estimate means for each group to plot later on
goby_out_model_estimates_control <- goby_out_model_estimates |> 
  dplyr::filter(stroke == "control") |> 
  rename(.value = emmean)

goby_out_model_estimates_four <- goby_out_model_estimates |> 
  dplyr::filter(stroke == "4")|> 
  rename(.value = emmean)

goby_out_model_estimates_two <- goby_out_model_estimates |> 
  dplyr::filter(stroke == "2")|> 
  rename(.value = emmean)
```

####  Plotting model estimates and raw data

```{r}
goby_out_model_draws <- goby_out_model |> 
  emmeans(~ stroke*stage,
          epred = TRUE,
          rg.limit = 14000,
          re_formula = NA) |> 
  gather_emmeans_draws()

goby_out_model_draws <- goby_out_model_draws |> 
  rename(emmean = .value)

goby_out_raw_data <- final_df |> 
  rename(emmean = goby_out)

goby_out_raw_data$stage <- factor(goby_out_raw_data$stage, levels = c("Pre", "During", "Post"))
goby_out_raw_data$stroke <- factor(goby_out_raw_data$stroke, levels = c("control", "4", "2"))

goby_out_model_estimates$stage <- factor(goby_out_model_estimates$stage, levels = c("Pre", "During", "Post"))
goby_out_model_estimates$stroke <- factor(goby_out_model_estimates$stroke, levels = c("control", "4", "2"))

goby_out_model_draws$stage <- factor(goby_out_model_draws$stage, levels = c("Pre", "During", "Post"))
goby_out_model_draws$stroke <- factor(goby_out_model_draws$stroke, levels = c("control", "4", "2"))

goby_out_means <- goby_out_raw_data |> 
  group_by(stage, stroke) |> 
  summarise(emmean = mean(emmean))


goby_out_fig_together <- ggplot(data = goby_out_raw_data, aes(x = stage, y = emmean, color = stroke, fill = stroke)) +
  geom_point(data = goby_out_means, alpha = 1, position = position_dodgenudge(width = 0.8, x = -0.09), size = 9, shape = "_") +
  geom_half_point(alpha = 0.3, position = position_dodgenudge(width = 0.8, x = -0.03), side = "l", range_scale = 0.5) +
  geom_half_violin(data = goby_out_model_draws, aes(x = stage, y = emmean, color = stroke, fill = stroke), alpha = 0.6, position = position_dodge(width = 0.8), side = "r", size = 0) +
  geom_point(data = goby_out_model_estimates, aes(x = stage, y = emmean, color = stroke), position = position_dodge(width = 0.8), size = 3) +
  geom_errorbar(data = goby_out_model_estimates, aes(x = stage, y = emmean, ymin = lower.HPD, ymax = upper.HPD, color = stroke), position = position_dodge(width = 0.8), width = 0, size = 1.25) +
  scale_fill_manual(values = c("control" = "#76A34A", "4" = "#F29E00", "2" = "#E25A00"), name = "Noise exposure", guide = guide_legend(override.aes = list(size = 3))) +
  scale_color_manual(values = c("control" = "#2A330E", "4" = "#805213", "2" = "#542709"), name = "Noise exposure", guide = guide_legend(override.aes = list(size = 3))) +
  scale_x_discrete(labels = c("Pre", "During", "Post")) +
  labs(title = "The effects of boat noise on goby burrow use",
       y = "Proportion of time in out of the burrow",
       x = "Experimental phase relative to noise exposure") +
  theme_classic() +
  theme(
    axis.text.x = element_text(size = 10, margin = margin(t = 5)),  
    axis.text.y = element_text(size = 10, margin = margin(r = 5)),  
    axis.title.x = element_text(size = 13, margin = margin(t = 10)),
    axis.title.y = element_text(size = 13, margin = margin(r = 10)),
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.position = "right",
    legend.justification = "top",
    plot.title = element_text(hjust = 0.5, size = 16),  
    plot.margin = margin(10, 10, 10, 10)
  )

goby_out_fig_together
```


#### Plotting control estimates and raw data

```{r}
goby_out_model_draws <- goby_out_model |> 
  emmeans(~ stroke*stage,
          epred = TRUE,
          rg.limit = 14000,
          re_formula = NA) |> 
  gather_emmeans_draws()

goby_out_raw_data <- final_df |>
  rename(.value = goby_out)

goby_out_model_draws$stage <- factor(goby_out_model_draws$stage, levels = c("Pre", "During", "Post"))
goby_out_model_draws$stroke <- factor(goby_out_model_draws$stroke, levels = c("control", "4", "2"))

goby_out_control_model_draws <- goby_out_model_draws |> 
  dplyr::filter(stroke == "control")

goby_control_raw_data <- final_df |> 
  dplyr::filter(stroke =="control") |> 
  rename(.value = goby_out)

goby_control_means <- goby_control_raw_data |> 
  group_by(stage) |> 
  summarise(.value = mean(.value))

goby_control_raw_data$stage <- factor(goby_control_raw_data$stage, levels = c("Pre", "During", "Post"))

#assigning a value for the baseline mean
goby_out_model_estimates_control_intercept <- goby_out_model_estimates_control %>%
  dplyr::filter(stage == "Pre") %>%
  pull(.value)

goby_out_fig_control <- ggplot(goby_control_raw_data, aes(y = .value, x = stage, fill = stage, color = stage)) +
  geom_half_violin(data = goby_out_control_model_draws, alpha = 0.7, size = 0, side = "r", position = position_nudge(x = 0.2)) +
  geom_jitter(position = position_jitternudge(x = -0.1, width = 0.1, nudge.from = "jittered"), alpha = 0.4, size = 2) +
  geom_crossbar(alpha = 0.6, size = 0.8, data = goby_out_model_estimates_control, aes(ymin = lower.HPD, ymax = upper.HPD), width = 0, position = position_nudge(x = 0.2))+
  geom_point(pch = 23, stroke = 1.2, data = goby_out_model_estimates_control, size = 2, position = position_nudge(x = 0.2)) +
  geom_point(data = goby_control_means, position = position_dodgenudge(width = 0.8, x = -0.1), size = 9, shape = "_") +
  labs(x="Period relative to treatment",
       y="Proportion of time out of burrow") +
  theme(legend.position = "none", 
        axis.title.x = element_blank(), 
        axis.text.x = element_text(size = 13),  
        axis.text.y = element_text(size = 13),
        panel.grid = element_blank(),
        axis.title.y = element_text(size = 16, face = "bold", margin = margin(t = 0, b = 0, l = 0, r = 10)),
        plot.title = element_textbox_simple(face = "bold", size = 16, halign = 0.5, linewidth = 0.3, linetype = 1, color = "black", fill = "#A3C088", padding = margin(5, 5, 5, 5)), 
        panel.background = element_rect(fill = "white", colour = "black"),
        plot.background = element_rect(fill = NA, colour = NA))+
  ggtitle("Control")+
  scale_fill_manual(values = c("Pre" = "darkgrey", "During" = "#76A34A", "Post" = "#D3D9A7")) +
  scale_color_manual(values = c("Pre" = "#242424", "During" = "#2A330E", "Post" = "#5d634c"))

goby_out_fig_control
```
#### Plotting 4-stroke estimates and raw data

```{r}
goby_out_control_model_draws <- goby_out_model_draws |> 
  dplyr::filter(stroke == "4")

goby_four_raw_data <- final_df |> 
  dplyr::filter(stroke =="4") |> 
  rename(.value = goby_out)

goby_four_raw_data$stage <- factor(goby_four_raw_data$stage, levels = c("Pre", "During", "Post"))

goby_four_means <- goby_four_raw_data |> 
  group_by(stage) |> 
  summarise(.value = mean(.value))

goby_out_fig_four <- ggplot(goby_four_raw_data, aes(y = .value, x = stage, fill = stage, color = stage)) +
  geom_half_violin(data = goby_out_control_model_draws, alpha = 0.7, size = 0, side = "r", position = position_nudge(x = 0.2)) +
  geom_jitter(position = position_jitternudge(x = -0.1, width = 0.1, nudge.from = "jittered"), alpha = 0.4, size = 2) +
  geom_crossbar(alpha = 0.6, size = 0.8, data = goby_out_model_estimates_four, aes(ymin = lower.HPD, ymax = upper.HPD), width = 0, position = position_nudge(x = 0.2))+
  geom_point(pch = 23, stroke = 1.2, data = goby_out_model_estimates_four, size = 2, position = position_nudge(x = 0.2)) +
  geom_point(data = goby_four_means, position = position_dodgenudge(width = 0.8, x = -0.1), size = 9, shape = "_") +
  xlab("Experimental phase relative to noise exposure")+
  theme(legend.position = "none", 
        axis.title.y = element_blank(),  
        axis.text.x = element_text(size = 13),  
        axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        panel.grid = element_blank(),
        axis.title.x = element_text(size = 16, face = "bold", margin = margin(t = 15, b = 0, l = 0, r = 0)),
        plot.title = element_textbox_simple(face = "bold", size = 16, halign = 0.5, linewidth = 0.3, linetype = 1, color = "black", fill = "#F6BC65", padding = margin(5, 5, 5, 5)), 
        panel.background = element_rect(fill = "white", colour = "black"),
        plot.background = element_rect(fill = NA, colour = NA))+
  ggtitle("4-stroke")+
  scale_fill_manual(values = c("Pre" = "darkgrey", "During" = "#F29E00", "Post" = "#F2D5A0")) +
  scale_color_manual(values = c("Pre" = "#242424", "During" = "#805213", "Post" = "#70532b"))

goby_out_fig_four
```

#### Plotting 2-stroke estimates and raw data

```{r}
goby_out_control_model_draws <- goby_out_model_draws |> 
  dplyr::filter(stroke == "2")

goby_two_raw_data <- final_df |> 
  dplyr::filter(stroke =="2") |> 
  rename(.value = goby_out)

goby_two_raw_data$stage <- factor(goby_two_raw_data$stage, levels = c("Pre", "During", "Post"))

goby_two_means <- goby_two_raw_data |> 
  group_by(stage) |> 
  summarise(.value = mean(.value))

goby_out_fig_two <- ggplot(goby_two_raw_data, aes(y = .value, x = stage, fill = stage, color = stage)) +
  geom_half_violin(data = goby_out_control_model_draws, alpha = 0.7, size = 0, side = "r", position = position_nudge(x = 0.2)) +
  geom_jitter(position = position_jitternudge(x = -0.1, width = 0.1, nudge.from = "jittered"), alpha = 0.4, size = 2) +
  geom_crossbar(alpha = 0.6, size = 0.8, data = goby_out_model_estimates_two, aes(ymin = lower.HPD, ymax = upper.HPD), width = 0, position = position_nudge(x = 0.2))+
  geom_point(pch = 23, stroke = 1.2, data = goby_out_model_estimates_two, size = 2, position = position_nudge(x = 0.2)) +
  geom_point(data = goby_two_means, position = position_dodgenudge(width = 0.8, x = -0.1), size = 9, shape = "_") +
  theme(legend.position = "none", 
        axis.title.x = element_blank(),  
        axis.text.x = element_text(size = 13),
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        panel.grid = element_blank(),
        plot.title = element_textbox_simple(face = "bold", size = 16, halign = 0.5, linewidth = 0.3, linetype = 1, color = "black", fill = "#EB9063", padding = margin(5, 5, 5, 5)), 
        panel.background = element_rect(fill = "white", colour = "black"),
        plot.background = element_rect(fill = NA, colour = NA))+
  ggtitle("2-stroke") +
  scale_fill_manual(values = c("Pre" = "darkgrey", "During" = "#E25A00", "Post" = "#F2B389")) +
  scale_color_manual(values = c("Pre" = "#242424", "During" = "#542709", "Post" = "#66422a"))

goby_out_fig_two
```

#### Combining plots into one figure

```{r, results='hide'}
goby_out_plot3 <- goby_out_fig_control + goby_out_fig_four + goby_out_fig_two + 
  plot_layout(ncol = 3)
```


```{r}
goby_out_plot3
ggsave("./2-figures/goby_out_plot3.jpeg", plot = goby_out_plot3, units = "px", width = 2200, height = 1400, dpi = 300)
ggsave("./2-figures/goby_out_plot3.pdf", plot = goby_out_plot3, units = "px", width = 2200, height = 1400)
```

### Estimating the effects of covariates on the proportion of time gobies spent outside of the burrow

#### Goby number

Estimates based on the number of gobies

```{r}
goby_out_model |>
  emmeans(~ goby_number, 
          epred = TRUE,
          re_formla = NULL)

goby_out_goby_number <- goby_out_model |>
  emmeans(~ goby_number, 
          epred = TRUE,
          re_formla = NULL) |> 
  contrast(method = "revpairwise")

goby_out_goby_number
```

Plotting contrast     

```{r}
goby_out_goby_number_draws <- goby_out_model |>
  emmeans(~ goby_number, 
          epred = TRUE,
          re_formla = NULL) |> 
  contrast(method = "revpairwise")|> 
  gather_emmeans_draws()

goby_out_goby_number_fig<- ggplot(goby_out_goby_number_draws, aes(x = .value, y = contrast)) +
   geom_vline(xintercept = 0, color = "black", size = 0.5) +
  stat_halfeye(.width = c(0.95))+
  labs(y = "Contrasts of the effect of the number of goby",
       fill = "Noise treatment", color = "Noise treatment",
       fill_ramp = "Credible interval") +
  xlab(NULL) +
  theme_classic() +
  coord_flip()

goby_out_goby_number_fig
```

#### Shrimp number

Estimates based on the number of shrimp   

```{r}
goby_out_shrimp_number <- goby_out_model |>
  emmeans(~ shrimp_number, 
          epred = TRUE,
          re_formla = NULL) |> 
  contrast(method = "revpairwise")

goby_out_shrimp_number

goby_out_shrimp_number_estimates <- goby_out_model |>
  emmeans(~ shrimp_number, 
          epred = TRUE,
          re_formla = NULL)

goby_out_shrimp_number_estimates
```

Plotting contrast  

```{r}
goby_out_shrimp_number_draws <- goby_out_model |>
  emmeans(~ shrimp_number, 
          epred = TRUE,
          re_formla = NULL) |> 
  contrast(method = "revpairwise")|> 
  gather_emmeans_draws()

goby_out_shrimp_number_fig<- ggplot(goby_out_shrimp_number_draws, aes(x = .value, y = contrast)) +
   geom_vline(xintercept = 0, color = "black", size = 0.5) +
  stat_halfeye(.width = c(0.95))+
  labs(y = "Contrasts of the effect of the number of shrimp",
       fill = "Noise treatment", color = "Noise treatment",
       fill_ramp = "Credible interval") +
  xlab(NULL) +
  theme_classic() +
  coord_flip()

goby_out_shrimp_number_fig
```

#### Shrimp species

```{r}
goby_out_shrimp_species <- goby_out_model |>
  emmeans(~ shrimp_species, 
          epred = TRUE,
          re_formla = NULL) |> 
  contrast(method = "revpairwise")

goby_out_shrimp_species <- as.data.frame(goby_out_shrimp_species)

goby_out_shrimp_species_estimates <- goby_out_model |>
  emmeans(~ shrimp_species, 
          epred = TRUE,
          re_formla = NULL)

goby_out_shrimp_species_estimates <- as.data.frame(goby_out_shrimp_species_estimates)

goby_out_shrimp_species_draws <- goby_out_model |>
  emmeans(~ shrimp_species, 
          epred = TRUE,
          re_formla = NULL) |> 
  contrast(method = "revpairwise")|> 
  gather_emmeans_draws()

goby_out_shrimp_species_fig<- ggplot(goby_out_shrimp_species_draws, aes(x = .value, y = contrast)) +
   geom_vline(xintercept = 0, color = "black", size = 0.5) +
  stat_halfeye(.width = c(0.95))+
  labs(y = "Contrasts of the effect of the species of shrimp",
       fill = "Noise treatment", color = "Noise treatment",
       fill_ramp = "Credible interval") +
  xlab(NULL) +
  coord_flip()

goby_out_shrimp_species_fig
```


## 🦐 Shrimp time outside of burrow

Model structure    

```{r}
shrimp_out_formula <- bf(
  # mu (mean) part
  shrimp_out ~ stroke*stage + shrimp_number + goby_number + shrimp_species + (1|site/burrow),
  # phi (precision) part
  phi ~ stroke*stage + shrimp_number + goby_number + shrimp_species + (1|site/burrow),
  # alpha (zero-one-inflation) part
  zoi ~ stroke*stage + shrimp_number + goby_number + shrimp_species + (1|site/burrow),
  # The one-inflated part, conditional on the 0s
  coi ~ stroke*stage + shrimp_number + goby_number + shrimp_species + (1|site/burrow),
  
  family = zero_one_inflated_beta()
)
```

Now we run and save the model.

⏭️ **Skip this step** if you have downloaded the saved model 'shrimp_out_model.rds'. You will load the model in the next step

```{r}
# shrimp_out_model <- brm(
#   shrimp_out_formula,
#   data = final_df,
#   family = zero_one_inflated_beta(),
#   prior = priors,
#   control = list(adapt_delta = 0.99,
#                  max_treedepth = 12),
#   chains = 4, iter = 4000, warmup = 1000,
#   cores = 4, threads = threading(2),
#   backend = "cmdstanr",
#   seed = 1,
#   file = "./3-models/shrimp_out_model"
# )
```

Here we reload the model.   

```{r}
shrimp_out_model <-  readRDS(file = "./3-models/shrimp_out_model.rds")
```


```{r}
summary(shrimp_out_model)
```


### Model fit and diagnostics

#### Model convergence

```{r}
extract_rhats(shrimp_out_model)
```

#### Model fit

```{r}
#posterior predictive checks
pp_check(shrimp_out_model)

pp_check(shrimp_out_model, type='stat', stat='mean')
```

Creating a summary of the observed data   

```{r}
summary(fitted(shrimp_out_model))
```

To compare with a summary of the predicted data, they seem to align very nicely.    

```{r}
summary(predict(shrimp_out_model))
```

```{r}
loo(shrimp_out_model)
```

### Posterior marginal effects

#### Pairwise contrasts of stroke and stage

```{r}
shrimp_out_contrasts <- shrimp_out_model |>
  emmeans(~ stroke*stage, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") 

# Extract the relevant contrast information
shrimp_out_contrasts <- as.data.frame(shrimp_out_contrasts) |> 
  dplyr::filter(contrast %in% c("control Pre - 2 Pre", "control Pre - 4 Pre","4 Pre - 2 Pre", "control Pre - control During", "control Pre - control Post", "4 Pre - 4 During", "4 Pre - 4 Post", "2 Pre - 2 During", "2 Pre - 2 Post"))

shrimp_out_contrasts
```


```{r}
shrimp_out_contrast_draws <- shrimp_out_model  |>
  emmeans(~ stroke*stage, 
          epred = TRUE,
          re_formula = NA) |> 
  contrast(method = "revpairwise") |> 
  gather_emmeans_draws()

shrimp_out_temporal_contrasts <- shrimp_out_contrast_draws |> 
  dplyr::filter(contrast %in% c("control Pre - control During", "control Pre - control Post", "4 Pre - 4 During", "4 Pre - 4 Post", "2 Pre - 2 During", "2 Pre - 2 Post")) |> 
  mutate(stroke = ifelse(contrast %in% c("control Pre - control During", "control Pre - control Post"), "Control", ifelse(contrast %in% c("4 Pre - 4 During", "4 Pre - 4 Post"), "4", "2")))

shrimp_out_temporal_contrasts$stroke <- factor(shrimp_out_temporal_contrasts$stroke, levels = c("Control", "4", "2"))

shrimp_out_temporal_contrasts_fig <- ggplot(shrimp_out_temporal_contrasts, aes(x = .value, y = factor(contrast, levels = c("control Pre - control During", "control Pre - control Post", "4 Pre - 4 During", "4 Pre - 4 Post",  "2 Pre - 2 During", "2 Pre - 2 Post")), color = stroke, fill = stroke)) +
  geom_vline(xintercept = 0, color = "black", size = 0.5) +
  stat_halfeye(.width = c(0.89, 0.95)) +
  scale_color_manual(values = c(colour11, colour12, colour13)) +
  scale_fill_manual(values = alpha(c(colour1, colour2, colour3), 0.8)) +
  labs(x = "Difference in the proportion of time spent out of the burrow",
       y = "Contrasts of the time periods relative to noise exposure",
       fill = "Noise treatment", color = "Noise treatment",
       fill_ramp = "Credible interval") +
  coord_flip() +
  theme(legend.position = "top", 
        axis.text.x = element_text(angle = 50, hjust =1)) +
  scale_y_discrete(labels = c("Pre - During", "Pre - Post", "Pre - During", "Pre - Post", "Pre - During", "Pre - Post")) +
  scale_x_continuous(breaks = seq(-0.2, 0.3, 0.1), labels = c("-0.2","-0.1" , "0", "0.1", "0.2", "0.3"), limits = c(-0.3, 0.4)) 


shrimp_out_temporal_contrasts_fig
```

### Extracting and plotting model estimates

#### Extracting estimates

```{r}
shrimp_out_model_estimates <- shrimp_out_model |> 
  emmeans(~ stroke*stage,
          epred = TRUE,
          rg.limit = 14000,
          re_formula = NA)

shrimp_out_model_estimates <- as.data.frame(shrimp_out_model_estimates)

shrimp_out_model_estimates

#Storing the model estimate means for each group to plot later on
shrimp_out_model_estimates_control <- shrimp_out_model_estimates |> 
  dplyr::filter(stroke == "control") |> 
  rename(.value = emmean)

shrimp_out_model_estimates_four <- shrimp_out_model_estimates |> 
  dplyr::filter(stroke == "4")|> 
  rename(.value = emmean)

shrimp_out_model_estimates_two <- shrimp_out_model_estimates |> 
  dplyr::filter(stroke == "2")|> 
  rename(.value = emmean)
```

#### Plotting model estimates and raw data

```{r}
shrimp_out_model_draws <- shrimp_out_model |> 
  emmeans(~ stroke*stage,
          epred = TRUE,
          rg.limit = 14000,
          re_formula = NA) |> 
  gather_emmeans_draws()

shrimp_out_model_draws <- shrimp_out_model_draws |> 
  rename(emmean = .value)

shrimp_out_raw_data <- final_df |> 
  rename(emmean = shrimp_out)

shrimp_out_raw_data$stage <- factor(shrimp_out_raw_data$stage, levels = c("Pre", "During", "Post"))
shrimp_out_raw_data$stroke <- factor(shrimp_out_raw_data$stroke, levels = c("control", "4", "2"))

shrimp_out_model_estimates$stage <- factor(shrimp_out_model_estimates$stage, levels = c("Pre", "During", "Post"))
shrimp_out_model_estimates$stroke <- factor(shrimp_out_model_estimates$stroke, levels = c("control", "4", "2"))

shrimp_out_model_draws$stage <- factor(shrimp_out_model_draws$stage, levels = c("Pre", "During", "Post"))
shrimp_out_model_draws$stroke <- factor(shrimp_out_model_draws$stroke, levels = c("control", "4", "2"))

shrimp_out_means <- shrimp_out_raw_data |> 
  group_by(stage, stroke) |> 
  summarise(emmean = mean(emmean))


shrimp_out_fig_together <- ggplot(data = shrimp_out_raw_data, aes(x = stage, y = emmean, color = stroke, fill = stroke)) +
  geom_point(data = shrimp_out_means, alpha = 1, position = position_dodgenudge(width = 0.8, x = -0.09), size = 9, shape = "_") +
  geom_half_point(alpha = 0.3, position = position_dodgenudge(width = 0.8, x = -0.03), side = "l", range_scale = 0.5) +
  geom_half_violin(data = shrimp_out_model_draws, aes(x = stage, y = emmean, color = stroke, fill = stroke), alpha = 0.6, position = position_dodge(width = 0.8), side = "r", size = 0) +
  geom_point(data = shrimp_out_model_estimates, aes(x = stage, y = emmean, color = stroke), position = position_dodge(width = 0.8), size = 3) +
  geom_errorbar(data = shrimp_out_model_estimates, aes(x = stage, y = emmean, ymin = lower.HPD, ymax = upper.HPD, color = stroke), position = position_dodge(width = 0.8), width = 0, size = 1.25) +
  scale_fill_manual(values = c("control" = "#76A34A", "4" = "#F29E00", "2" = "#E25A00"), name = "Noise exposure", guide = guide_legend(override.aes = list(size = 3))) +
  scale_color_manual(values = c("control" = "#2A330E", "4" = "#805213", "2" = "#542709"), name = "Noise exposure", guide = guide_legend(override.aes = list(size = 3))) +
  scale_x_discrete(labels = c("Pre", "During", "Post")) +
  labs(title = "The effects of boat noise on shrimp burrow use",
       y = "Proportion of time in out of the burrow",
       x = "Experimental phase relative to noise exposure") +
  theme_classic() +
  theme(
    axis.text.x = element_text(size = 10, margin = margin(t = 5)),  
    axis.text.y = element_text(size = 10, margin = margin(r = 5)),  
    axis.title.x = element_text(size = 13, margin = margin(t = 10)),
    axis.title.y = element_text(size = 13, margin = margin(r = 10)),
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.position = "right",
    legend.justification = "top",
    plot.title = element_text(hjust = 0.5, size = 16),  
    plot.margin = margin(10, 10, 10, 10)
  )

shrimp_out_fig_together
```


#### Plotting control estimates and raw data

```{r}
shrimp_out_model_draws <- shrimp_out_model |> 
  emmeans(~ stroke*stage,
          epred = TRUE,
          rg.limit = 14000,
          re_formula = NA) |> 
  gather_emmeans_draws()

shrimp_out_raw_data <- final_df |>
  rename(.value = shrimp_out)

shrimp_out_model_draws$stage <- factor(shrimp_out_model_draws$stage, levels = c("Pre", "During", "Post"))
shrimp_out_model_draws$stroke <- factor(shrimp_out_model_draws$stroke, levels = c("control", "4", "2"))

shrimp_out_control_model_draws <- shrimp_out_model_draws |> 
  dplyr::filter(stroke == "control")

shrimp_control_raw_data <- final_df |> 
  dplyr::filter(stroke =="control") |> 
  rename(.value = shrimp_out)

shrimp_control_means <- shrimp_control_raw_data |> 
  group_by(stage) |> 
  summarise(.value = mean(.value))

shrimp_control_raw_data$stage <- factor(shrimp_control_raw_data$stage, levels = c("Pre", "During", "Post"))

#assigning a value for the baseline mean
shrimp_out_model_estimates_control_intercept <- shrimp_out_model_estimates_control %>%
  dplyr::filter(stage == "Pre") %>%
  pull(.value)

shrimp_out_fig_control <- ggplot(shrimp_control_raw_data, aes(y = .value, x = stage, fill = stage, color = stage)) +
  geom_half_violin(data = shrimp_out_control_model_draws, alpha = 0.7, size = 0, side = "r", position = position_nudge(x = 0.2)) +
  geom_jitter(position = position_jitternudge(x = -0.1, width = 0.1, nudge.from = "jittered"), alpha = 0.4, size = 2) +
  geom_crossbar(alpha = 0.6, size = 0.8, data = shrimp_out_model_estimates_control, aes(ymin = lower.HPD, ymax = upper.HPD), width = 0, position = position_nudge(x = 0.2))+
  geom_point(pch = 23, stroke = 1.2, data = shrimp_out_model_estimates_control, size = 2, position = position_nudge(x = 0.2)) +
  geom_point(data = shrimp_control_means, position = position_dodgenudge(width = 0.8, x = -0.1), size = 9, shape = "_") +
  labs(x="Period relative to treatment",
       y="Proportion of time out of burrow") +
  theme(legend.position = "none", 
        axis.title.x = element_blank(), 
        axis.text.x = element_text(size = 13),  
        axis.text.y = element_text(size = 13),
        panel.grid = element_blank(),
        axis.title.y = element_text(size = 16, face = "bold", margin = margin(t = 0, b = 0, l = 0, r = 10)),
        plot.title = element_textbox_simple(face = "bold", size = 16, halign = 0.5, linewidth = 0.3, linetype = 1, color = "black", fill = "#A3C088", padding = margin(5, 5, 5, 5)), 
        panel.background = element_rect(fill = "white", colour = "black"),
        plot.background = element_rect(fill = NA, colour = NA))+
  ggtitle("Control")+
  scale_fill_manual(values = c("Pre" = "darkgrey", "During" = "#76A34A", "Post" = "#D3D9A7")) +
  scale_color_manual(values = c("Pre" = "#242424", "During" = "#2A330E", "Post" = "#5d634c"))

shrimp_out_fig_control
```

#### Plotting 4-stroke estimates and raw data

```{r}
shrimp_out_control_model_draws <- shrimp_out_model_draws |> 
  dplyr::filter(stroke == "4")

shrimp_four_raw_data <- final_df |> 
  dplyr::filter(stroke =="4") |> 
  rename(.value = shrimp_out)

shrimp_four_raw_data$stage <- factor(shrimp_four_raw_data$stage, levels = c("Pre", "During", "Post"))

shrimp_four_means <- shrimp_four_raw_data |> 
  group_by(stage) |> 
  summarise(.value = mean(.value))

shrimp_out_fig_four <- ggplot(shrimp_four_raw_data, aes(y = .value, x = stage, fill = stage, color = stage)) +
  geom_half_violin(data = shrimp_out_control_model_draws, alpha = 0.7, size = 0, side = "r", position = position_nudge(x = 0.2)) +
  geom_jitter(position = position_jitternudge(x = -0.1, width = 0.1, nudge.from = "jittered"), alpha = 0.4, size = 2) +
  geom_crossbar(alpha = 0.6, size = 0.8, data = shrimp_out_model_estimates_four, aes(ymin = lower.HPD, ymax = upper.HPD), width = 0, position = position_nudge(x = 0.2))+
  geom_point(pch = 23, stroke = 1.2, data = shrimp_out_model_estimates_four, size = 2, position = position_nudge(x = 0.2)) +
  geom_point(data = shrimp_four_means, position = position_dodgenudge(width = 0.8, x = -0.1), size = 9, shape = "_") +
  xlab("Experimental phase relative to noise exposure")+
  theme(legend.position = "none", 
        axis.title.y = element_blank(),  
        axis.text.x = element_text(size = 13),  
        axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        panel.grid = element_blank(),
        axis.title.x = element_text(size = 16, face = "bold", margin = margin(t = 15, b = 0, l = 0, r = 0)),
        plot.title = element_textbox_simple(face = "bold", size = 16, halign = 0.5, linewidth = 0.3, linetype = 1, color = "black", fill = "#F6BC65", padding = margin(5, 5, 5, 5)), 
        panel.background = element_rect(fill = "white", colour = "black"),
        plot.background = element_rect(fill = NA, colour = NA))+
  ggtitle("4-stroke")+
  scale_fill_manual(values = c("Pre" = "darkgrey", "During" = "#F29E00", "Post" = "#F2D5A0")) +
  scale_color_manual(values = c("Pre" = "#242424", "During" = "#805213", "Post" = "#70532b"))

shrimp_out_fig_four
```

#### Plotting 2-stroke estimates and raw data

```{r}
shrimp_out_control_model_draws <- shrimp_out_model_draws |> 
  dplyr::filter(stroke == "2")

shrimp_two_raw_data <- final_df |> 
  dplyr::filter(stroke =="2") |> 
  rename(.value = shrimp_out)

shrimp_two_raw_data$stage <- factor(shrimp_two_raw_data$stage, levels = c("Pre", "During", "Post"))

shrimp_two_means <- shrimp_two_raw_data |> 
  group_by(stage) |> 
  summarise(.value = mean(.value))

shrimp_out_fig_two <- ggplot(shrimp_two_raw_data, aes(y = .value, x = stage, fill = stage, color = stage)) +
  geom_half_violin(data = shrimp_out_control_model_draws, alpha = 0.7, size = 0, side = "r", position = position_nudge(x = 0.2)) +
  geom_jitter(position = position_jitternudge(x = -0.1, width = 0.1, nudge.from = "jittered"), alpha = 0.4, size = 2) +
  geom_crossbar(alpha = 0.6, size = 0.8, data = shrimp_out_model_estimates_two, aes(ymin = lower.HPD, ymax = upper.HPD), width = 0, position = position_nudge(x = 0.2))+
  geom_point(pch = 23, stroke = 1.2, data = shrimp_out_model_estimates_two, size = 2, position = position_nudge(x = 0.2)) +
  geom_point(data = shrimp_two_means, position = position_dodgenudge(width = 0.8, x = -0.1), size = 9, shape = "_") +
  theme(legend.position = "none", 
        axis.title.x = element_blank(),  
        axis.text.x = element_text(size = 13),
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        panel.grid = element_blank(),
        plot.title = element_textbox_simple(face = "bold", size = 16, halign = 0.5, linewidth = 0.3, linetype = 1, color = "black", fill = "#EB9063", padding = margin(5, 5, 5, 5)), 
        panel.background = element_rect(fill = "white", colour = "black"),
        plot.background = element_rect(fill = NA, colour = NA))+
  ggtitle("2-stroke") +
  scale_fill_manual(values = c("Pre" = "darkgrey", "During" = "#E25A00", "Post" = "#F2B389")) +
  scale_color_manual(values = c("Pre" = "#242424", "During" = "#542709", "Post" = "#66422a"))

shrimp_out_fig_two
```

#### Combining plots into one figure

```{r}
shrimp_out_plot3 <- shrimp_out_fig_control + shrimp_out_fig_four + shrimp_out_fig_two + 
  plot_layout(ncol = 3)

shrimp_out_plot3
ggsave("./2-figures/shrimp_out_plot3.jpeg", plot = shrimp_out_plot3, units = "px", width = 2200, height = 1400, dpi = 300)
ggsave("./2-figures/shrimp_out_plot3.pdf", plot = shrimp_out_plot3, units = "px", width = 2200, height = 1400)
```

### Estimating the effects of covariates on the proportion of time shrimp spent outside of the burrow

#### Goby number

```{r}
shrimp_out_goby_number_contrasts <- shrimp_out_model |>
  emmeans(~ goby_number, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") 

shrimp_out_goby_number_contrasts
```

####  Shrimp number

```{r}
shrimp_out_shrimp_number_contrasts <- shrimp_out_model |>
  emmeans(~ shrimp_number, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") 

shrimp_out_shrimp_number_contrasts <- as.data.frame(shrimp_out_shrimp_number_contrasts)

shrimp_out_shrimp_number_estimates <- shrimp_out_model |>
  emmeans(~ shrimp_number, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000)

shrimp_out_shrimp_number_estimates
```


```{r}
shrimp_out_shrimp_number_contrast_draws <- shrimp_out_model |>
  emmeans(~ shrimp_number, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") |> 
  gather_emmeans_draws()

ggplot(data = shrimp_out_shrimp_number_contrast_draws, aes(x = contrast, y = .value )) +
  stat_halfeye()
```
#### Shrimp species

```{r}
shrimp_out_shrimp_species_contrasts <- shrimp_out_model |>
  emmeans(~ shrimp_species, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") 

shrimp_out_shrimp_species_contrasts

shrimp_out_shrimp_species_contrasts_draws <- shrimp_out_model |>
  emmeans(~ shrimp_species, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") |> 
  gather_emmeans_draws()

ggplot(data = shrimp_out_shrimp_species_contrasts_draws, aes(x = contrast, y = .value )) +
  stat_halfeye()
```

## 🐟-🦐 Modelling the proportion of time shrimp spent in contact with the goby

### Checking the response variable distribution

```{r}
shrimp_contact_df <- final_df |> 
  mutate(is_zero = shrimp_contact == 0)

shrimp_contact_plot <- shrimp_contact_df |> 
  mutate(shrimp_contact = ifelse(is_zero, -0.1, shrimp_contact)) |> 
  ggplot(aes(x = shrimp_contact)) +
  geom_histogram(aes(fill = is_zero), binwidth = 0.05, 
                 boundary = 0, color = "white") +
  geom_vline(xintercept = 0)
shrimp_contact_plot
# Distribution is a zero-one inflated beta distribution, because the value for shrimp_contact is bounded by 0-1 as it is a proportion of the total time and there is values of 0 and 1.
```

### Running the model

Now we run and save the model.

⏭️ **Skip this step** if you have downloaded the saved model 'shrimp_contact_model.rds'. You will load the model in the next step.

```{r}
# shrimp_contact_model <- brm(
#   bf(shrimp_contact ~ stroke*stage + shrimp_number + goby_number + shrimp_species + (1|site/burrow),
#      phi ~ stroke*stage + shrimp_number + goby_number + shrimp_species + (1|site/burrow),
#      zoi ~ stroke*stage + shrimp_number + goby_number + shrimp_species + (1|site/burrow),
#      coi ~ stroke*stage + shrimp_number + goby_number + shrimp_species + (1|site/burrow)
#      ),
#   data = final_df,
#   prior = priors,
#   family = zero_one_inflated_beta(),
#   control = list(adapt_delta = 0.99, max_treedepth = 12),
#   chains = 4, iter = 6000, warmup = 1000, seed = 1, backend = "cmdstanr", cores = 4, threads = threading(2),
#   file = "./3-models/shrimp_contact_model"
# )
```

Here we reload the model.   

```{r}
shrimp_contact_model <-  readRDS(file = "./3-models/shrimp_contact_model.rds")
```


```{r}
summary(shrimp_contact_model)
```

### Model fit and diagnostics

#### Model convergence

```{r}
extract_rhats(shrimp_contact_model)
```

#### Model fit

```{r}
#posterior predictive checks
pp_check(shrimp_contact_model)

pp_check(shrimp_contact_model, type='stat', stat='mean')
```



```{r}
summary(fitted(shrimp_contact_model))
```



```{r}
summary(predict(shrimp_contact_model))
```

### Posterior marginal effects

#### Pairwise contrasts of stroke and stage


```{r}
shrimp_contact_contrasts <- shrimp_contact_model |>
  emmeans(~ stroke*stage, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") 

overall_mean <- shrimp_contact_model |>
  emmeans(~ 1,             # 1 means "no factors," i.e. the grand mean
          epred = TRUE,    # estimate on the response scale
          re_formla = NULL,
          rg.limit = 14000)

# View the summary with posterior mean and credible intervals
overall_mean

# Extract the relevant contrast information
shrimp_contact_contrasts <- as.data.frame(shrimp_contact_contrasts) |> 
  dplyr::filter(contrast %in% c("control Pre - 2 Pre", "control Pre - 4 Pre","4 Pre - 2 Pre", "control Pre - control During", "control Pre - control Post", "4 Pre - 4 During", "4 Pre - 4 Post", "2 Pre - 2 During", "2 Pre - 2 Post"))

shrimp_contact_contrasts
```


```{r}
shrimp_contact_contrasts_draws <- shrimp_contact_model  |>
  emmeans(~ stroke*stage, 
          epred = TRUE,
          re_formula = NA) |> 
  contrast(method = "revpairwise") |> 
  gather_emmeans_draws()

shrimp_contact_temporal_contrasts <- shrimp_contact_contrasts_draws |> 
  dplyr::filter(contrast %in% c("control Pre - control During", "control Pre - control Post","control Post - control During" , "4 Pre - 4 During", "4 Pre - 4 Post", "4 Post - 4 During", "2 Pre - 2 During", "2 Pre - 2 Post", "2 Post - 2 During")) |> 
  mutate(stroke = ifelse(contrast %in% c("control Pre - control During", "control Pre - control Post","control Post - control During"), "Control", ifelse(contrast %in% c("4 Pre - 4 During", "4 Pre - 4 Post", "4 Post - 4 During"), "4", "2")))

shrimp_contact_temporal_contrasts$stroke <- factor(shrimp_contact_temporal_contrasts$stroke, levels = c("Control", "4", "2"))

shrimp_contact_temporal_fig<- ggplot(shrimp_contact_temporal_contrasts, aes(x = .value, y = factor(contrast, levels = c("control Pre - control During", "control Pre - control Post","control Post - control During" , "4 Pre - 4 During", "4 Pre - 4 Post", "4 Post - 4 During", "2 Pre - 2 During", "2 Pre - 2 Post", "2 Post - 2 During")), color = stroke, fill = stroke)) +
   geom_vline(xintercept = 0, color = "black", size = 0.5) +
  stat_halfeye(.width = c(0.89, 0.95)) +
  scale_color_manual(values = c(colour11, colour12, colour13)) +
  scale_fill_manual(values = alpha(c(colour1, colour2, colour3), 0.8)) +
  labs(x = "Difference in the proportion of time spent in contact",
       y = "Contrasts of the time periods relative to noise exposure",
       fill = "Noise treatment", color = "Noise treatment",
       fill_ramp = "Credible interval") +
  coord_flip() +
  theme(legend.position = "top", 
        axis.text.x = element_text(angle = 50, hjust =1)) +
  scale_y_discrete(labels = c("Pre - During", "Pre - Post","Post - During" , "Pre - During", "Pre - Post", "Post - During", "Pre - During", "Pre - Post", "Post - During")) +
  scale_x_continuous(breaks = seq(-0.2, 0.3, 0.1), labels = c("-0.2","-0.1" , "0", "0.1", "0.2", "0.3"), limits = c(-0.2, 0.3)) 


shrimp_contact_temporal_fig
```

### Extracting and plotting model estimates

#### Extracting estimates
```{r}
shrimp_contact_model_estimates <- shrimp_contact_model |> 
  emmeans(~ stroke*stage,
          epred = TRUE,
          rg.limit = 14000,
          re_formula = NA)

shrimp_contact_model |> 
  emmeans(~ 1,
          epred = TRUE,
          rg.limit = 14000,
          re_formula = NA)

shrimp_contact_model_estimates <- as.data.frame(shrimp_contact_model_estimates)

shrimp_contact_model_estimates

#Storing the model estimate means for each group to plot later on
shrimp_contact_model_estimates_control <- shrimp_contact_model_estimates |> 
  dplyr::filter(stroke == "control") |> 
  rename(.value = emmean)

shrimp_contact_model_estimates_four <- shrimp_contact_model_estimates |> 
  dplyr::filter(stroke == "4")|> 
  rename(.value = emmean)

shrimp_contact_model_estimates_two <- shrimp_contact_model_estimates |> 
  dplyr::filter(stroke == "2")|> 
  rename(.value = emmean)
```
#### Plotting model estimates and raw data

```{r}
shrimp_contact_model_draws <- shrimp_contact_model |> 
  emmeans(~ stroke*stage,
          epred = TRUE,
          rg.limit = 14000,
          re_formula = NA) |> 
  gather_emmeans_draws()

shrimp_contact_model_draws <- shrimp_contact_model_draws |> 
  rename(emmean = .value)

shrimp_contact_raw_data <- final_df |> 
  rename(emmean = shrimp_contact)

shrimp_contact_raw_data$stage <- factor(shrimp_contact_raw_data$stage, levels = c("Pre", "During", "Post"))
shrimp_contact_raw_data$stroke <- factor(shrimp_contact_raw_data$stroke, levels = c("control", "4", "2"))

shrimp_contact_model_estimates$stage <- factor(shrimp_contact_model_estimates$stage, levels = c("Pre", "During", "Post"))
shrimp_contact_model_estimates$stroke <- factor(shrimp_contact_model_estimates$stroke, levels = c("control", "4", "2"))

shrimp_contact_model_draws$stage <- factor(shrimp_contact_model_draws$stage, levels = c("Pre", "During", "Post"))
shrimp_contact_model_draws$stroke <- factor(shrimp_contact_model_draws$stroke, levels = c("control", "4", "2"))

shrimp_contact_means <- shrimp_contact_raw_data |> 
  group_by(stage, stroke) |> 
  summarise(emmean = mean(emmean))


shrimp_contact_fig_together <- ggplot(data = shrimp_contact_raw_data, aes(x = stage, y = emmean, color = stroke, fill = stroke)) +
  geom_point(data = shrimp_contact_means, alpha = 1, position = position_dodgenudge(width = 0.8, x = -0.09), size = 9, shape = "_") +
  geom_half_point(alpha = 0.3, position = position_dodgenudge(width = 0.8, x = -0.03), side = "l", range_scale = 0.5) +
  geom_half_violin(data = shrimp_contact_model_draws, aes(x = stage, y = emmean, color = stroke, fill = stroke), alpha = 0.6, position = position_dodge(width = 0.8), side = "r", size = 0) +
  geom_point(data = shrimp_contact_model_estimates, aes(x = stage, y = emmean, color = stroke), position = position_dodge(width = 0.8), size = 3) +
  geom_errorbar(data = shrimp_contact_model_estimates, aes(x = stage, y = emmean, ymin = lower.HPD, ymax = upper.HPD, color = stroke), position = position_dodge(width = 0.8), width = 0, size = 1.25) +
  scale_fill_manual(values = c("control" = "#76A34A", "4" = "#F29E00", "2" = "#E25A00"), name = "Noise exposure", guide = guide_legend(override.aes = list(size = 3))) +
  scale_color_manual(values = c("control" = "#2A330E", "4" = "#805213", "2" = "#542709"), name = "Noise exposure", guide = guide_legend(override.aes = list(size = 3))) +
  scale_x_discrete(labels = c("Pre", "During", "Post")) +
  labs(title = "The effects of boat noise on goby-shrimp contact",
       y = "Proportion of time the in contact",
       x = "Experimental phase relative to noise exposure") +
  theme_classic() +
  theme(
    axis.text.x = element_text(size = 10, margin = margin(t = 5)),  
    axis.text.y = element_text(size = 10, margin = margin(r = 5)),  
    axis.title.x = element_text(size = 13, margin = margin(t = 10)),
    axis.title.y = element_text(size = 13, margin = margin(r = 10)),
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.position = "right",
    legend.justification = "top",
    plot.title = element_text(hjust = 0.5, size = 16),  
    plot.margin = margin(10, 10, 10, 10)
  )

shrimp_contact_fig_together
ggsave("./2-figures/shrimp_contact_fig_together.png", plot = shrimp_contact_fig_together, units = "px", width = 2200, height = 1400, dpi = 300)
```


#### Plotting control estimates and raw data

```{r}
shrimp_contact_model_draws <- shrimp_contact_model |> 
  emmeans(~ stroke*stage,
          epred = TRUE,
          rg.limit = 14000,
          re_formula = NA) |> 
  gather_emmeans_draws()

shrimp_contact_raw_data <- final_df |>
  rename(.value = shrimp_contact)

shrimp_contact_model_draws$stage <- factor(shrimp_contact_model_draws$stage, levels = c("Pre", "During", "Post"))
shrimp_contact_model_draws$stroke <- factor(shrimp_contact_model_draws$stroke, levels = c("control", "4", "2"))

shrimp_contact_control_model_draws <- shrimp_contact_model_draws |> 
  dplyr::filter(stroke == "control")

goby_control_raw_data <- final_df |> 
  dplyr::filter(stroke =="control") |> 
  rename(.value = shrimp_contact)

goby_control_means <- goby_control_raw_data |> 
  group_by(stage) |> 
  summarise(.value = mean(.value))

goby_control_raw_data$stage <- factor(goby_control_raw_data$stage, levels = c("Pre", "During", "Post"))

#assigning a value for the baseline mean
shrimp_contact_model_estimates_control_intercept <- shrimp_contact_model_estimates_control %>%
  dplyr::filter(stage == "Pre") %>%
  pull(.value)

shrimp_contact_fig_control <- ggplot(goby_control_raw_data, aes(y = .value, x = stage, fill = stage, color = stage)) +
  geom_half_violin(data = shrimp_contact_control_model_draws, alpha = 0.7, size = 0, side = "r", position = position_nudge(x = 0.2)) +
  geom_jitter(position = position_jitternudge(x = -0.1, width = 0.1, nudge.from = "jittered"), alpha = 0.4, size = 2) +
  geom_crossbar(alpha = 0.6, size = 0.8, data = shrimp_contact_model_estimates_control, aes(ymin = lower.HPD, ymax = upper.HPD), width = 0, position = position_nudge(x = 0.2))+
  geom_point(pch = 23, stroke = 1.2, data = shrimp_contact_model_estimates_control, size = 2, position = position_nudge(x = 0.2)) +
  geom_point(data = goby_control_means, position = position_dodgenudge(width = 0.8, x = -0.1), size = 9, shape = "_") +
  labs(x="Period relative to treatment",
       y="Proportion of time in contact") +
  theme(legend.position = "none", 
        axis.title.x = element_blank(), 
        axis.text.x = element_text(size = 13),  
        axis.text.y = element_text(size = 13),
        axis.title.y = element_text(size = 16, face = "bold", margin = margin(t = 0, b = 0, l = 0, r = 10)),
        plot.title = element_textbox_simple(face = "bold", size = 16, halign = 0.5, linewidth = 0.3, linetype = 1, color = "black", fill = "#A3C088", padding = margin(5, 5, 5, 5)), 
        panel.background = element_rect(fill = "white", colour = "black"),
        plot.background = element_rect(fill = NA, colour = NA))+
  ggtitle("Control")+
  scale_fill_manual(values = c("Pre" = "darkgrey", "During" = "#76A34A", "Post" = "#D3D9A7")) +
  scale_color_manual(values = c("Pre" = "#242424", "During" = "#2A330E", "Post" = "#5d634c"))

shrimp_contact_fig_control
```

#### Plotting 4-stroke estimates and raw data

```{r}
shrimp_contact_control_model_draws <- shrimp_contact_model_draws |> 
  dplyr::filter(stroke == "4")

goby_four_raw_data <- final_df |> 
  dplyr::filter(stroke =="4") |> 
  rename(.value = shrimp_contact)

goby_four_raw_data$stage <- factor(goby_four_raw_data$stage, levels = c("Pre", "During", "Post"))

goby_four_means <- goby_four_raw_data |> 
  group_by(stage) |> 
  summarise(.value = mean(.value))

shrimp_contact_fig_four <- ggplot(goby_four_raw_data, aes(y = .value, x = stage, fill = stage, color = stage)) +
  geom_half_violin(data = shrimp_contact_control_model_draws, alpha = 0.7, size = 0, side = "r", position = position_nudge(x = 0.2)) +
  geom_jitter(position = position_jitternudge(x = -0.1, width = 0.1, nudge.from = "jittered"), alpha = 0.4, size = 2) +
  geom_crossbar(alpha = 0.6, size = 0.8, data = shrimp_contact_model_estimates_four, aes(ymin = lower.HPD, ymax = upper.HPD), width = 0, position = position_nudge(x = 0.2))+
  geom_point(pch = 23, stroke = 1.2, data = shrimp_contact_model_estimates_four, size = 2, position = position_nudge(x = 0.2)) +
  geom_point(data = goby_four_means, position = position_dodgenudge(width = 0.8, x = -0.1), size = 9, shape = "_") +
  xlab("Experimental phase relative to noise exposure")+
  theme(legend.position = "none", 
        axis.title.y = element_blank(),  
        axis.text.x = element_text(size = 13),  
        axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        axis.title.x = element_text(size = 16, face = "bold", margin = margin(t = 15, b = 0, l = 0, r = 0)),
        plot.title = element_textbox_simple(face = "bold", size = 16, halign = 0.5, linewidth = 0.3, linetype = 1, color = "black", fill = "#F6BC65", padding = margin(5, 5, 5, 5)), 
        panel.background = element_rect(fill = "white", colour = "black"),
        plot.background = element_rect(fill = NA, colour = NA))+
  ggtitle("4-stroke")+
  scale_fill_manual(values = c("Pre" = "darkgrey", "During" = "#F29E00", "Post" = "#F2D5A0")) +
  scale_color_manual(values = c("Pre" = "#242424", "During" = "#805213", "Post" = "#70532b"))

shrimp_contact_fig_four
```

#### Plotting 2-stroke estimates and raw data

```{r}
shrimp_contact_control_model_draws <- shrimp_contact_model_draws |> 
  dplyr::filter(stroke == "2")

goby_two_raw_data <- final_df |> 
  dplyr::filter(stroke =="2") |> 
  rename(.value = shrimp_contact)

goby_two_raw_data$stage <- factor(goby_two_raw_data$stage, levels = c("Pre", "During", "Post"))

goby_two_means <- goby_two_raw_data |> 
  group_by(stage) |> 
  summarise(.value = mean(.value))

shrimp_contact_fig_two <- ggplot(goby_two_raw_data, aes(y = .value, x = stage, fill = stage, color = stage)) +
  geom_half_violin(data = shrimp_contact_control_model_draws, alpha = 0.7, size = 0, side = "r", position = position_nudge(x = 0.2)) +
  geom_jitter(position = position_jitternudge(x = -0.1, width = 0.1, nudge.from = "jittered"), alpha = 0.4, size = 2) +
  geom_crossbar(alpha = 0.6, size = 0.8, data = shrimp_contact_model_estimates_two, aes(ymin = lower.HPD, ymax = upper.HPD), width = 0, position = position_nudge(x = 0.2))+
  geom_point(pch = 23, stroke = 1.2, data = shrimp_contact_model_estimates_two, size = 2, position = position_nudge(x = 0.2)) +
  geom_point(data = goby_two_means, position = position_dodgenudge(width = 0.8, x = -0.1), size = 9, shape = "_") +
  theme(legend.position = "none", 
        axis.title.x = element_blank(),  
        axis.text.x = element_text(size = 13),
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        plot.title = element_textbox_simple(face = "bold", size = 16, halign = 0.5, linewidth = 0.3, linetype = 1, color = "black", fill = "#EB9063", padding = margin(5, 5, 5, 5)), 
        panel.background = element_rect(fill = "white", colour = "black"),
        plot.background = element_rect(fill = NA, colour = NA))+
  ggtitle("2-stroke") +
  scale_fill_manual(values = c("Pre" = "darkgrey", "During" = "#E25A00", "Post" = "#F2B389")) +
  scale_color_manual(values = c("Pre" = "#242424", "During" = "#542709", "Post" = "#66422a"))

shrimp_contact_fig_two
```

#### Combining plots into one figure

```{r}
shrimp_contact_plot3 <- shrimp_contact_fig_control + shrimp_contact_fig_four + shrimp_contact_fig_two + 
  plot_layout(ncol = 3)
```


```{r}
shrimp_contact_plot3
ggsave("./2-figures/shrimp_contact_plot3.jpeg", plot = shrimp_contact_plot3, units = "px", width = 2200, height = 1400, dpi = 300)
ggsave("./2-figures/shrimp_contact_plot3.pdf", plot = shrimp_contact_plot3, units = "px", width = 2200, height = 1400)
```

### Estimating the effect of covariates on the proportion of time spent in contact

#### Goby number

```{r}
shrimp_contact_goby_number_contrasts <- shrimp_contact_model |>
  emmeans(~ goby_number, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") 

shrimp_contact_goby_number_contrasts
```

#### Shrimp number

```{r}
shrimp_contact_shrimp_number_contrasts <- shrimp_contact_model |>
  emmeans(~ shrimp_number, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") 

shrimp_contact_shrimp_number_contrasts
```

#### Shrimp species

```{r}
shrimp_contact_shrimp_species_contrasts <- shrimp_contact_model |>
  emmeans(~ shrimp_species, 
          epred = TRUE,
          re_formla = NULL,
          rg.limit =14000) |> 
  contrast(method = "revpairwise") 

shrimp_contact_shrimp_species_contrasts
```

# Manuscript output files

## Supp tables

### Model estimates

```{r}
goby_out_model_estimates <- goby_out_model_estimates |> 
  mutate(`Behavioural measure` = "Proportion of time gobies spent outside of the burrow")
  
shrimp_out_model_estimates <- shrimp_out_model_estimates |> 
  mutate(`Behavioural measure` = "Proportion of time shrimp spent outside of the burrow")
  
shrimp_contact_model_estimates <- shrimp_contact_model_estimates |> 
  mutate(`Behavioural measure` = "Proportion of time shrimp spent in contact with a goby")
  
model_estimates <- bind_rows(goby_out_model_estimates, 
                             shrimp_out_model_estimates, 
                             shrimp_contact_model_estimates)

model_estimates <- model_estimates |>
  mutate(stroke = ifelse(stroke == "4", "4-stroke", ifelse(stroke == "2", "2-stroke", "control")),
         stroke = factor(stroke, levels = c("control", "4-stroke", "2-stroke")),
         stage = factor(stage, levels = c("Pre", "During", "Post")),
         `Behavioural measure` = factor(`Behavioural measure`, levels = c("Proportion of time gobies spent outside of the burrow", "Proportion of time shrimp spent outside of the burrow", "Proportion of time shrimp spent in contact with a goby"))) |>
  arrange(`Behavioural measure`, stage, stroke) |> 
  rename(`Estimated marginal mean` = emmean,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Phase = stage,
         `Noise exposure` = stroke) |> 
  select(c(`Behavioural measure`, Phase, `Noise exposure`, `Estimated marginal mean`, `Lower 95% CrI`, `Upper 95% CrI`))

write_csv(model_estimates, "./1-data/model_estimates.csv")
```

### Pairwise contrasts

```{r}
#goby out
goby_out_contrasts <- goby_out_results.table |> 
  mutate(`Predictor variable` = "Treatment and phase interaction",
         contrast = str_replace_all(contrast, "\\b2\\b", "2-Stroke"),
         contrast = str_replace_all(contrast, "\\b4\\b", "4-Stroke"),
         contrast = str_replace_all(contrast, "\\bcontrol\\b", "Control")
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))

goby_out_goby_number1 <- goby_out_goby_number |>
  as.data.frame() |> 
  mutate(`Predictor variable` = "Number of gobies",
         contrast = str_replace_all(contrast, "\\bgoby_number2\\b", "2 gobies"),
         contrast = str_replace_all(contrast, "\\bgoby_number1\\b", "1 goby")
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))
  
goby_out_shrimp_number1 <- goby_out_shrimp_number |> 
  as.data.frame() |> 
  mutate(`Predictor variable` = "Number of shrimp",
         contrast = str_replace_all(contrast, "\\bshrimp_number2\\b", "2 shrimp"),
         contrast = str_replace_all(contrast, "\\bshrimp_number1\\b", "1 shrimp"),
         contrast = str_replace_all(contrast, "\\bshrimp_number3\\b", "3 shrimp")
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))

goby_out_shrimp_species1 <- goby_out_shrimp_species |> 
  as.data.frame() |> 
  mutate(`Predictor variable` = "Shrimp species"
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))

goby_out_contrasts_table <- rbind(goby_out_contrasts, goby_out_goby_number1, goby_out_shrimp_number1, goby_out_shrimp_species1) |>
  mutate(
    `Estimated marginal difference` = round(`Estimated marginal difference`, 3),
    `Lower 95% CrI` = round(`Lower 95% CrI`, 3),
    `Upper 95% CrI` = round(`Upper 95% CrI`, 3)
  )

write_csv(goby_out_contrasts_table, "./1-data/goby_out_contrasts_table.csv")

#shrimp out
shrimp_out_contrasts1 <- shrimp_out_contrasts |> 
  mutate(`Predictor variable` = "Treatment and phase interaction",
         contrast = str_replace_all(contrast, "\\b2\\b", "2-Stroke"),
         contrast = str_replace_all(contrast, "\\b4\\b", "4-Stroke"),
         contrast = str_replace_all(contrast, "\\bcontrol\\b", "Control")
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))

shrimp_out_goby_number_contrasts1 <- shrimp_out_goby_number_contrasts |>
  as.data.frame() |> 
  mutate(`Predictor variable` = "Number of gobies",
         contrast = str_replace_all(contrast, "\\bgoby_number2\\b", "2 gobies"),
         contrast = str_replace_all(contrast, "\\bgoby_number1\\b", "1 goby")
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))
  
shrimp_out_shrimp_number_contrasts1 <- shrimp_out_shrimp_number_contrasts |> 
  as.data.frame() |> 
  mutate(`Predictor variable` = "Number of shrimp",
         contrast = str_replace_all(contrast, "\\bshrimp_number2\\b", "2 shrimp"),
         contrast = str_replace_all(contrast, "\\bshrimp_number1\\b", "1 shrimp"),
         contrast = str_replace_all(contrast, "\\bshrimp_number3\\b", "3 shrimp")
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))

shrimp_out_shrimp_species_contrasts1 <- shrimp_out_shrimp_species_contrasts |> 
  as.data.frame() |> 
  mutate(`Predictor variable` = "Shrimp species"
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))

shrimp_out_contrasts_table <- rbind(shrimp_out_contrasts1, shrimp_out_goby_number_contrasts1, shrimp_out_shrimp_number_contrasts1, shrimp_out_shrimp_species_contrasts1) |>
  mutate(
    `Estimated marginal difference` = round(`Estimated marginal difference`, 3),
    `Lower 95% CrI` = round(`Lower 95% CrI`, 3),
    `Upper 95% CrI` = round(`Upper 95% CrI`, 3)
  )

write_csv(shrimp_out_contrasts_table, "./1-data/shrimp_out_contrasts_table.csv")

#shrimp contact
shrimp_contact_contrasts1 <- shrimp_contact_contrasts |> 
  mutate(`Predictor variable` = "Treatment and phase interaction",
         contrast = str_replace_all(contrast, "\\b2\\b", "2-Stroke"),
         contrast = str_replace_all(contrast, "\\b4\\b", "4-Stroke"),
         contrast = str_replace_all(contrast, "\\bcontrol\\b", "Control")
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))

shrimp_contact_goby_number_contrasts1 <- shrimp_contact_goby_number_contrasts |>
  as.data.frame() |> 
  mutate(`Predictor variable` = "Number of gobies",
         contrast = str_replace_all(contrast, "\\bgoby_number2\\b", "2 gobies"),
         contrast = str_replace_all(contrast, "\\bgoby_number1\\b", "1 goby")
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))

shrimp_contact_shrimp_number_contrasts1 <- shrimp_contact_shrimp_number_contrasts |> 
  as.data.frame() |> 
  mutate(`Predictor variable` = "Number of shrimp",
         contrast = str_replace_all(contrast, "\\bshrimp_number2\\b", "2 shrimp"),
         contrast = str_replace_all(contrast, "\\bshrimp_number1\\b", "1 shrimp"),
         contrast = str_replace_all(contrast, "\\bshrimp_number3\\b", "3 shrimp")
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))

shrimp_contact_shrimp_species_contrasts1 <- shrimp_contact_shrimp_species_contrasts |> 
  as.data.frame() |> 
  mutate(`Predictor variable` = "Shrimp species"
         ) |> 
  rename(`Estimated marginal difference` = estimate,
         `Lower 95% CrI` = lower.HPD,
         `Upper 95% CrI` = upper.HPD,
         Contrast = contrast) |> 
  select(c(`Predictor variable`, Contrast, `Estimated marginal difference`, `Lower 95% CrI`, `Upper 95% CrI`))

shrimp_contact_contrasts_table <- rbind(shrimp_contact_contrasts1, shrimp_contact_goby_number_contrasts1, shrimp_contact_shrimp_number_contrasts1, shrimp_contact_shrimp_species_contrasts1) |>
  mutate(
    `Estimated marginal difference` = round(`Estimated marginal difference`, 3),
    `Lower 95% CrI` = round(`Lower 95% CrI`, 3),
    `Upper 95% CrI` = round(`Upper 95% CrI`, 3)
  )

write_csv(shrimp_contact_contrasts_table, "./1-data/shrimp_contact_contrasts_table.csv")
```


```{r}
table_S1 <- final_df %>%
  select(c("burrow", "stroke", "site")) |> 
  unique() |> 
  group_by(site, stroke) %>%
  summarise(n = n(), .groups = "drop") %>%
  pivot_wider(names_from = stroke, values_from = n, values_fill = 0) %>%
  mutate(Total = `control` + `4` + `2`) %>%
  arrange(site) %>%
  rename(`4-stroke` = `4`, 
         `2-stroke` = `2`, 
         Control = control)
```


#Delete me I am one of Jack's rabbit holes 

```{r}
priors <- c(set_prior("student_t(3, 0, 2.5)", class = "Intercept"),
            set_prior("logistic(0, 3)", class = "Intercept", dpar = "coi"),
            set_prior("logistic(0, 3)", class = "Intercept", dpar = "zoi"),
            set_prior("student_t(3, 0, 2.5)", class = "Intercept", dpar = "phi", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", dpar = "phi", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", dpar = "zoi", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", dpar = "coi", lb = 0),
            set_prior("normal(0, 3)", class = "b"),
            set_prior("normal(0, 3)", class = "b", dpar = "phi"),
            set_prior("normal(0, 3)", class = "b", dpar = "zoi"),
            set_prior("normal(0, 3)", class = "b", dpar = "coi"))


priors1 <- c(set_prior("student_t(3, 0, 2.5)", class = "Intercept"),
            set_prior("logistic(0, 3)", class = "Intercept", dpar = "zoi"),
            set_prior("student_t(3, 0, 2.5)", class = "Intercept", dpar = "phi", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", dpar = "phi", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", dpar = "zoi", lb = 0),
            set_prior("normal(0, 3)", class = "b"),
            set_prior("normal(0, 3)", class = "b", dpar = "phi"),
            set_prior("normal(0, 3)", class = "b", dpar = "zoi"))

priors2 <- c(set_prior("student_t(3, 0, 2.5)", class = "Intercept"),
            set_prior("student_t(3, 0, 2.5)", class = "sd", lb = 0),
            set_prior("normal(0, 3)", class = "b"))

priors3 <- c(set_prior("student_t(3, 0, 2.5)", class = "Intercept"),
            set_prior("logistic(0, 3)", class = "Intercept", dpar = "coi"),
            set_prior("logistic(0, 3)", class = "Intercept", dpar = "zoi"),
            set_prior("student_t(3, 0, 2.5)", class = "Intercept", dpar = "phi", lb = 0),
            set_prior("student_t(3, 0, 2.5)", class = "sd", lb = 0),
            set_prior("normal(0, 3)", class = "b"),
            set_prior("normal(0, 3)", class = "b", dpar = "phi"),
            set_prior("normal(0, 3)", class = "b", dpar = "zoi"),
            set_prior("normal(0, 3)", class = "b", dpar = "coi"))

priors4 <- c(set_prior("student_t(3, 0, 2.5)", class = "Intercept"),
            set_prior("normal(0, 3)", class = "b"))
```

```{r}
goby_out_formula_simple1 <- bf(
  # mu (mean) part
  goby_out ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # phi (precision) part
  phi ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # alpha (zero-one-inflation) part
  zoi ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # The one-inflated part, conditional on the 0s
  coi ~ 1,
  
  family = zero_one_inflated_beta()
)

goby_out_model_simple1 <- brm(
  goby_out_formula_simple1,
  data = final_df,
  family = zero_one_inflated_beta(),
  prior = priors1,
  control = list(adapt_delta = 0.99,
                 max_treedepth = 12),
  chains = 4, iter = 4000, warmup = 1000,
  cores = 4, threads = threading(2),
  backend = "cmdstanr",
  seed = 1
)
```


```{r}
goby_out_formula_simple2 <- bf(
  # mu (mean) part
  goby_out ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # phi (precision) part
  phi ~ stroke*stage + goby_number + shrimp_number + shrimp_species,
  # alpha (zero-one-inflation) part
  zoi ~ 1,
  # The one-inflated part, conditional on the 0s
  coi ~ 1,
  
  family = zero_one_inflated_beta()
)

goby_out_model_simple2 <- brm(
  goby_out_formula_simple2,
  data = final_df,
  family = zero_one_inflated_beta(),
  prior = priors2,
  control = list(adapt_delta = 0.99,
                 max_treedepth = 12),
  chains = 4, iter = 4000, warmup = 1000,
  cores = 4, threads = threading(2),
  backend = "cmdstanr",
  seed = 1
)
```

```{r}
goby_out_formula_simple3 <- bf(
  # mu (mean) part
  goby_out ~ stroke*stage + goby_number + shrimp_number + shrimp_species + (1 | site/burrow),
  # phi (precision) part
  phi ~ stroke*stage + goby_number + shrimp_number + shrimp_species,
  # alpha (zero-one-inflation) part
  zoi ~ stroke*stage + goby_number + shrimp_number + shrimp_species,
  # The one-inflated part, conditional on the 0s
  coi ~ stroke*stage + goby_number + shrimp_number + shrimp_species,
  
  family = zero_one_inflated_beta()
)

goby_out_model_simple3 <- brm(
  goby_out_formula_simple3,
  data = final_df,
  family = zero_one_inflated_beta(),
  prior = priors3,
  control = list(adapt_delta = 0.99,
                 max_treedepth = 12),
  chains = 4, iter = 4000, warmup = 1000,
  cores = 4, threads = threading(2),
  backend = "cmdstanr",
  seed = 1
)
```

```{r}
goby_out_formula_simple4 <- bf(
  # mu (mean) part
  goby_out ~ stroke*stage + goby_number + shrimp_number + shrimp_species,
  # phi (precision) part
  phi ~ stroke*stage + goby_number + shrimp_number + shrimp_species,
  # alpha (zero-one-inflation) part
  zoi ~ 1,
  # The one-inflated part, conditional on the 0s
  coi ~ 1,
  
  family = zero_one_inflated_beta()
)

goby_out_model_simple4 <- brm(
  goby_out_formula_simple4,
  data = final_df,
  family = zero_one_inflated_beta(),
  prior = priors4,
  control = list(adapt_delta = 0.99,
                 max_treedepth = 12),
  chains = 4, iter = 4000, warmup = 1000,
  cores = 4, threads = threading(2),
  backend = "cmdstanr",
  seed = 1
)
```


```{r}
pp_check(goby_out_model, ndraws = 50)
pp_check(goby_out_model_simple1, ndraws = 50)
pp_check(goby_out_model_simple2, ndraws = 50)
pp_check(goby_out_model_simple3, ndraws = 50)
pp_check(goby_out_model_simple4, ndraws = 50)
pp_check(goby_out_model, type='stat', stat='mean')
pp_check(goby_out_model_simple1, type='stat', stat='mean')
pp_check(goby_out_model_simple2, type='stat', stat='mean')
pp_check(goby_out_model_simple3, type='stat', stat='mean')
pp_check(goby_out_model_simple4, type='stat', stat='mean')
```

```{r}
loo(goby_out_model_simple1)
```


```{r}
loo(goby_out_model_simple2)
```


```{r}
loo(goby_out_model_simple3)
```

```{r}
loo(goby_out_model_simple4)
```
